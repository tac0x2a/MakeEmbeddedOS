「12ステップで作る組み込みOS自作入門」のメモ．

# シリアル通信
* シリアル通信みたいなIFは信号線の周期の管理とか面倒なので，``コントローラ`` という専用チップが制御している．LANならLANコントローラ，とか．
* コントローラの制御はレジスタ経由で行う． [serial.c](/serial.c)  を参照．
* デバイスやチップごとに比較器が設けられており，アドレスバスの上位n本と，チップごとにユニークなnビットを比較して，一致した場合はそのチップを有効にする，みたいな感じでアドレス空間を分けている．このチップを有効にする信号を``CS(Chip Select)`` や ``CE(Chip Enable)`` と呼ぶ．このようにアドレスバスの一部を使ってチップを選択できることで，``メモリマップドIO``が実現されている．

# スタートアップ
* スタートアップとは，スタックポインタの設定してmain()へ飛ばすなど，プログラムの動作開始処理のこと．スタートアップを表す名前として， ``crt(C RunTime)`` ``locore`` とかが使われるらしい．
* 「割り込みハンドラを記述しておく特定のアドレス」のことを ``割り込みベクタ`` という．
* H8の場合は，割り込みベクタは 0x000000 - 0x0000ff に配置されている．
* H8は電源ON時にリセット割り込みが入り，ベクタテーブル先頭に配置されたリセット割り込みハンドラをコールする．そこにスタートアップのアドレスを登録しているので，電源投入時にスタートアップが動作するというわけ．


# 領域
## メモリ上の領域について
* ``テキスト領域`` - CPUが実行する機械語コード
* ``データ領域`` - 初期値を **持つ** 静的変数
* ``BSS領域`` - 初期値を **持たない** 静的変数
* 静的変数の配置先は，初期値の有無によって，データ領域かBSSに分けられる．後者は領域のサイズのみを持つため，実行形式ファイルのサイズを節約できる．

## 実行形式ファイル中の領域について
* 実行形式ファイルは内部で領域が分割されており，特定の領域単位でメモリ上へコピーされる．この領域のことを ``セクション`` という．
* 大抵の実行形式ファイルは，前述の3つのセクションを持っている．それぞれ， ``.text``, ``.data``, ``.bss`` に対応している．
* セクションの先頭に ``ヘッダ`` として，そのセクションの情報を保持している．
* この本では [ELF(Executable and Linkable Format)](http://ja.wikipedia.org/wiki/Executable_and_Linkable_Format)  を扱ってる．
* ``readelf`` コマンドで解析できるよ．

```
%readelf -a <解析したい実行形式ファイル>
```

* ``.text`` セクションは H8/3069F の内蔵FlashROMがマッピングされているアドレスになっているため，CPUはROMから命令を読み込んで実行している
* ``.data`` や ``.bss`` が ROM上にマッピングされていると，変数を読めるけど変更できない！ みたいなことになる．


## リンカスクリプト
* プログラムのどの部分が，どのアドレスに配置されるかはリンクの時点で決まる．この指定を行うのが ``リンカスクリプト``． [ld.src](/ld.src)
* `` . `` は ``ロケーションカウンタ`` といい，カレントアドレスを示す． `` . = 0x0; `` は以降のセクションは0番地から配置するよ，という意味．

```
.vectors : {
    vector.o(.data)
}
/* これで， vector.o内のvectorsを.dataに置く，って意味になる */
```

```
MEMORY
{
  /** 0xdeadから0xbeefを hoge というRW領域として命名する,みたいなかんじ */
  hoge(rw) : o = 0xdead, l = 0xbeef

  /**こんなかんじに重複してもOK */
  romall(rx):o = 0x000000, l = 0x080000
  vectors(r):o = 0x000000, l = 0x000100 
}

SECTIONS{

  /* 割り込みベクタ */
  .vectors : {
    vector.o(.data)
  } > vectors /** これで、vectors領域を使うってかんじになる **/


...
  /* BSS領域 */
  .bss : {
    _bss_start = . ;
    *(.bss)
    *(COMMON)
    _ebss = . ;
  } > data AT> rom 
/** AT> は物理アドレスの指定。こう書くと、data領域に格納されるんだけど、 *
 * 実際はRAMの上の領域を読み書きするような機械語になる */

} /** end of SECTION */
```

このままではだめで、ROMに置かれた初期値をRAMへコピーする必要がある。

## セクションと領域の違い

* 領域 - MEMORYコマンドで定義した領域。
* セクション - プログラムを領域に割り当てたもの。
	
## セグメントはこうなった
```
プログラムヘッダ:
タイプ   オフセット 仮想Addr   物理Addr   FileSiz MemSiz  Flg Align
LOAD   0x000094 0x00000000 0x00000000 0x00100 0x00100 RW  0x1
LOAD   0x000194 0x00000100 0x00000100 0x003e0 0x003e0 R E 0x1
LOAD   0x000574 0x00fffc20 0x000004e0 0x00010 0x00014 RW  0x1
```

``FileSiz`` が実行形式ファイル上のサイズ、 ``MemSiz`` が展開後のサイズ。
3つめのセグメントが ``.data`` と ``.bss`` が展開されるセグメント。 
FileSizとMemSizが違うのは、 .bss領域が実際に展開されるため。
前半が.dataセクションで、後半が.bssセクションになっている。
ロード作業では、.dataセクションはコピーして、残りの.bssセクションはゼロクリアすればOK。

ちなみに、この3つめのセグメントの物理Addrは `erodata` のアドレスと一致する。何故こうなるのか、わからん。。。。 
2つ目のセクションが read-only なデータが置かれるから、３つ目のセクションの物理Addr先頭になってるのかな。。。

# ブートローダ
電源ONでブートローダを起動して、シリアル経由でプログラムをダウンロードして起動するようにするらしい。
このように段階的を踏んでOSを起動する手順を ``ブートストラップ`` と呼ぶ。
フラッシュメモリは書き換え回数に制限があるので、開発時はブートローダでプログラムをRAMに展開するが、製品化の段階でフラッシュROMに書き込んでROM上から起動するようにする。(``ROM化``)

## XMODEM
シンプルなシリアル経由でのファイル転送プロトコル。

### 送信側 
* 受信側から定期的に送られる ``NAK(0x15)`` を受けたら送信開始。
* データは固定長のブロック単位で送る。ファイル終端でデータが足りない場合は ``EOF(0x01)`` で埋める。
* 1ブロック送るたびに ``ACK(0x06)`` か ``NAK`` が返ってくるのを待つ. ``NAK`` が返ってきたら再送しなければならない。
* データの終わりは ``EOT(0x04)`` を送信して、 ``ACK``が返ってきたら終了。
* 中断する場合は ``CAN(0x18)`` を送信する。 ``CAN`` が返ってきたら中断できた。

### 受信側
* 受信準備できたら、定期的にNAKを送信する。
* ``SOH(0x01)``を受け取ったらブロックを受信する。成功したら``ACK``を返す。
* ``EOT``を受けたら``ACK``を返して終了する。
* 中断したい場合は ``CAN`` を送る。 ``CAN`` が返ってきたら中断できた。

ブロックは先頭から・・・
* 1byte SOH
* 1byte ブロック番号 1から255の連番をループ。
* 1byte ブロック番号をビット反転したもの(チェック用)
* 128byte データ。128byteに満たない場合はEOFで埋める。
* 1byte データ部のチェックサム

# アセンブラ
OS自作でアセンブラが必要になるところ

* スタートアップ
* 割り込みの入り口と出口
* スレッドのディスパッチ 

## スタック
* 関数単位でスタック上に確保される領域を``スタックフレーム``という。
* スタックフレームの先頭を``フレームポインタ``という。このフレームポインタを起点に自動変数のアドレス計算を行う。(デバッグ時に関数の自動変数を確認したりするのに使う)
* gccでは *-fomit-frame-pointer* オプションでビルドするとフレームポインタを使わず、コンパクトで高速な実行形式を生成できる。(デバッガに影響は出るが。。。)
* スタック獲得時にアドレスの値が少なくなる方向に伸びていくのを``下方伸長``という。

## ニーモニックとアセンブラ
* 命令部を``オペコード ``、レジスタ番号やアドレスなどの引数に相当する部分を``オペランド``という。
* オペコードを *ld* や *st* などの単語で表現したものが``ニーモニック``。
こうして、ニーモニックで表した機械語プログラムの表記を``アセンブリ言語``という。
* アセンブリ言語を機械語コードへ変換することを``アセンブル``、その逆を``逆アセンブル``という。
* ``$ objdump -d *.elf`` で、逆アセンブルできる。
* スタック獲得時にアドレスの値が少なくなる方向に伸びていくのを``下方伸長``という。
* メモリ参照の方法を``アドレッシング・モード``と呼ぶ。レジスタ値をアドレス値とするのを``レジスタ間接``という。
* 関数呼び出しは ``jsr`` 、関数からの復帰は ``rts`` という命令で行われる。
* ``ラベル``はC言語の関数名や変数名に相当するもの。

## ABI(Application Binary Interface)

``ABI(Application Binary Interface)`` という規格があり、引数渡しや戻り値返却など、CPUごとにどのレジスタをどのように使用するか決まっている。そのため、ABIに準拠しているコンパイラなら、異なるコンパイラで生成したオブジェクトファイル同士をリンクしてそのCPUで実行することができる。

# ELFフォーマット
## セクションとセグメント
それぞれ目的が違うので、単位や必要な情報が微妙に異なっていることに注意。
これらの情報は、ELFファイル内で ``セクションヘッダ``、``プログラムヘッダ`` として管理されている。

### ``セクション``はリンカのための情報
コンパイルして作られる各オブジェクトファイルは、実はELFフォーマットになっている。
各オブジェクトファイルごとに、機械語コードは.text、変数などのデータは.dataなど、同じ領域にまとめられている。この **データの種類ごとの領域がセクション**。
リンクして実行ファイルを生成する際、リンカスクリプトで細かい設定をしなければ、各オブジェクトのセクションが同じセクションへまとめられ、実行ファイル(ELFフォーマット)が作られる。

### ``セグメント``はローダのための情報
リンク後の実行ファイルを生成される際に作られる。
プログラムを実行する際に、実行形式ファイルのイメージは``ローダ``と呼ばれるプログラムによってメモリに展開される。ELFフォーマット解析してロードするプログラムなら *ELFローダ* らしい。 この **ロードの際のメモリ展開の単位がセグメント**。
ローダは、実行形式ファイルのセグメント情報を参照して、そこに書かれているとおりに実行形式ファイル中の領域を **セグメント単位で**実メモリへ展開する。


### ヘッダ情報
#### セクションヘッダ
* セクションの開始位置とサイズ。ELFファイル内のどこからどこまでがそのセクションとして扱われるかを示す。
* セクションごとに独立して位置とサイズを持てるので、どのセクションをどの領域のどこからどこまで配置するかを柔軟に保持できる。

#### プログラムヘッダ
* こちらも同様に、開始位置とサイズを指定することで、セグメントを不連続に配置したり重複させたりできる。
* セクションヘッダとプログラムヘッダは独立しているので、複数のセグメントにまたがったセクションを定義することもできる。

## ELFフォーマットの内部構造
ファイルの先頭から順に・・・

* **ELFヘッダ** - プログラムヘッダテーブルやセクションヘッダテーブルの情報を持つ
* **プログラムヘッダテーブル** - セグメントに関する情報を持つ
* **セグメント1**
  * **セクション1-1**
  * ...
  * **セクション1-n**
* **セグメント2**
  * **セクション2-1**
  * ...
  * **セクション2-m**
* ...
* **セクションヘッダテーブル** - セクションに関する情報を持つ

実際には、セグメントがセクションを包含する構成になることが多い。こうしておくと、同じような役割のセクションを同一セグメントにまとめて、一緒に展開することができるので。 リンカスクリプトで特殊な構成にしない限り、こんなかんじになるらしい。

### ELFヘッダ
```ELFヘッダの例
ELF ヘッダ:
  マジック:  7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00
  クラス:                            ELF32
  データ:                            2 の補数、ビッグエンディアン
  バージョン:                        1 (current)
  OS/ABI:                            UNIX - System V
  ABI バージョン:                    0
  型:                                EXEC (実行可能ファイル)
  マシン:                            Renesas H8/300
  バージョン:                        0x1
  エントリポイントアドレス:          0x100
  プログラムの開始ヘッダ:            52 (バイト)
  セクションヘッダ始点:              2424 (バイト)
  フラグ:                            0x810000
  このヘッダのサイズ:                52 (バイト)
  プログラムヘッダサイズ:            32 (バイト)
  プログラムヘッダ数:                3
  セクションヘッダ:                  40 (バイト)
  セクションヘッダサイズ:            9
  セクションヘッダ文字列表索引:      6
```
* 先頭16バイトはELFの識別領域になっている。
* 先頭4バイトは``マジックナンバ``で、必ず ``0x7F, 0x45 0x4c 0x46 = 0x7F,'E','L','F'`` になっている。その後に動作可能なアーキテクチャのビット数や、エンディアン、ELFフォーマットのバージョンなどが入っている。

### セクションヘッダテーブル
```セクションヘッダテーブルの例
セクションヘッダ:
  [番] 名前              タイプ          アドレス Off    サイズ ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .vectors          PROGBITS        00000000 000094 000100 00  WA  0   0  4
  [ 2] .text             PROGBITS        00000100 000194 0006f6 00  AX  0   0  2
  [ 3] .rodata           PROGBITS        000007f6 00088a 00009e 01 AMS  0   0  1
  [ 4] .data             PROGBITS        00fffc20 000928 000010 00  WA  0   0  4
  [ 5] .bss              NOBITS          00fffc30 000938 000010 00  WA  0   0  1
  [ 6] .shstrtab         STRTAB          00000000 000938 00003d 00      0   0  1
  [ 7] .symtab           SYMTAB          00000000 000ae0 000600 10      8  64  4
  [ 8] .strtab           STRTAB          00000000 0010e0 00024b 00      0   0  1
```
* セクション名は4バイトしか確保されていないので、``.shstrtab`` セクションにまとめて格納されている。
* ``Addr``は物理アドレス。そのセクションが動作するアドレス。
* ``Off``はELFファイル内でどの部分がそのセクションとなるのかを表す。

### プログラムヘッダテーブル
```プログラムヘッダテーブルの例
プログラムヘッダ:
  タイプ       オフセット 仮想Addr   物理Addr   FileSiz MemSiz  Flg Align
  LOAD           0x000094 0x00000000 0x00000000 0x00100 0x00100 RW  0x1
  LOAD           0x000194 0x00000100 0x00000100 0x00794 0x00794 R E 0x1
  LOAD           0x000928 0x00fffc20 0x00000894 0x00010 0x00020 RW  0x1

 セグメントマッピングへのセクション:
  セグメントセクション...
   00     .vectors
   01     .text .rodata
   02     .data .bss
```
* `Type`は種別を表す。`LOAD`はメモリ上にロードされるセグメントという意味。他にも *動的リンク情報* や *プログラムヘッダ自身* というものもある。
* `Offset`はセクションヘッダテーブルと同様に、ELFファイル内の位置を表す。
* `FileSiz`はELFファイル内のサイズ、`MmSiz`はメモリ上のサイズ。たとえば.bssはメモリ上には展開されるがELFファイル内のサイズはゼロ。
* `Flg`には`R` `W` `E`が表示され、そのセクションの読み書き実行が可能かどうかを表しており、ローダがロード時に設定を行ってから起動することでメモリ保護が可能。ちなみにH8はメモリ保護機能がないのであまり意味が無い。

### プログラムヘッダは先頭付近、セクションヘッダは末尾に位置する理由
* ダウンロードしながらセグメントをメモリへ展開する場合を考慮して、プログラムヘッダは先頭付近に配置されている。
* セクションヘッダは実行ファイルには不要な情報なので、ローダは途中から読み捨てることができるように末尾に配置されている。先頭にあると読み捨てた場合のオフセット計算がめんどくさいし。

# 論理回路
## マルチプレクサ
* `マルチプレクサ` は入力された値に応じて、複数の入力から一つを選んで出力する回路。`データセレクタ`とも。
* マルチプレクサを使うことで特定のメモリのデータを読み出すことができる。
