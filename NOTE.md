12ステップで作る組み込みOS自作入門 のメモ．

## シリアル通信
* シリアル通信みたいなIFは信号線の周期の管理とか面倒なので，``コントローラ`` という専用チップが制御している．LANならLANコントローラ，とか．
* コントローラの制御はレジスタ経由で行う． [serial.c](/serial.c)  を参照．
* デバイスやチップごとに比較器が設けられており，アドレスバスの上位n本と，チップごとにユニークなnビットを比較して，一致した場合はそのチップを有効にする，みたいな感じでアドレス空間を分けている．このチップを有効にする信号を``CS(Chip Select)`` や ``CE(Chip Enable)`` と呼ぶ．このようにアドレスバスの一部を使ってチップを選択できることで，``メモリマップドIO``が実現されている．

## スタートアップ
* スタートアップとは，スタックポインタの設定してmain()へ飛ばすなど，プログラムの動作開始処理のこと．スタートアップを表す名前として， ``crt(C RunTime)`` ``locore`` とかが使われるらしい．
* 「割り込みハンドラを記述しておく特定のアドレス」のことを ``割り込みベクタ`` という．
* H8の場合は，割り込みベクタは 0x000000 - 0x0000ff に配置されている．
* H8は電源ON時にリセット割り込みが入り，ベクタテーブル先頭に配置されたリセット割り込みハンドラをコールする．そこにスタートアップのアドレスを登録しているので，電源投入時にスタートアップが動作するというわけ．


## 領域
### メモリ上の領域について
* ``テキスト領域`` - CPUが実行する機械語コード
* ``データ領域`` - 初期値を **持つ** 静的変数
* ``BSS領域`` - 初期値を **持たない** 静的変数
* 静的変数の配置先は，初期値の有無によって，データ領域かBSSに分けられる．後者は領域のサイズのみを持つため，実行形式ファイルのサイズを節約できる．

### 実行形式ファイル中の領域について
* 実行形式ファイルは内部で領域が分割されており，特定の領域単位でメモリ上へコピーされる．この領域のことを ``セクション`` という．
* 大抵の実行形式ファイルは，前述の3つのセクションを持っている．それぞれ， ``.text``, ``.data``, ``.bss`` に対応している．
* セクションの先頭に ``ヘッダ`` として，そのセクションの情報を保持している．
* この本では [ELF(Executable and Linkable Format)](http://ja.wikipedia.org/wiki/Executable_and_Linkable_Format)  を扱ってる．
* ``readelf`` コマンドで解析できるよ．

```
%readelf -a <解析したい実行形式ファイル>
```

* ``.text`` セクションは H8/3069F の内蔵FlashROMがマッピングされているアドレスになっているため，CPUはROMから命令を読み込んで実行している
* ``.data`` や ``.bss`` が ROM上にマッピングされていると，変数を読めるけど変更できない！ みたいなことになる．


### リンカスクリプト
* プログラムのどの部分が，どのアドレスに配置されるかはリンクの時点で決まる．この指定を行うのが ``リンカスクリプト``． [ld.src](/ld.src)
* `` . `` は ``ロケーションカウンタ`` といい，カレントアドレスを示す． `` . = 0x0; `` は以降のセクションは0番地から配置するよ，という意味．

```
.vectors : {
    vector.o(.data)
}
/* これで， vector.o内のvectorsを.dataに置く，って意味になる */
```

```
MEMORY
{
  /** 0xdeadから0xbeefを hoge というRW領域として命名する,みたいなかんじ */
  hoge(rw) : o = 0xdead, l = 0xbeef

  /**こんなかんじに重複してもOK */
  romall(rx):o = 0x000000, l = 0x080000
  vectors(r):o = 0x000000, l = 0x000100 
}

SECTIONS{

  /* 割り込みベクタ */
  .vectors : {
    vector.o(.data)
  } > vectors /** これで、vectors領域を使うってかんじになる **/


...
  /* BSS領域 */
  .bss : {
    _bss_start = . ;
    *(.bss)
    *(COMMON)
    _ebss = . ;
  } > data AT> rom 
/** AT> は物理アドレスの指定。こう書くと、data領域に格納されるんだけど、 *
 * 実際はRAMの上の領域を読み書きするような機械語になる */

} /** end of SECTION */
```

このままではだめで、ROMに置かれた初期値をRAMへコピーする必要がある。

### セクションと領域の違い

* 領域 - MEMORYコマンドで定義した領域。
* セクション - プログラムを領域に割り当てたもの。
	
### セグメントはこうなった
```
プログラムヘッダ:
タイプ   オフセット 仮想Addr   物理Addr   FileSiz MemSiz  Flg Align
LOAD   0x000094 0x00000000 0x00000000 0x00100 0x00100 RW  0x1
LOAD   0x000194 0x00000100 0x00000100 0x003e0 0x003e0 R E 0x1
LOAD   0x000574 0x00fffc20 0x000004e0 0x00010 0x00014 RW  0x1
```

``FileSiz`` が実行形式ファイル上のサイズ、 ``MemSiz`` が展開後のサイズ。
3つめのセグメントが ``.data`` と ``.bss`` が展開されるセグメント。 
FileSizとMemSizが違うのは、 .bss領域が実際に展開されるため。
前半が.dataセクションで、後半が.bssセクションになっている。
ロード作業では、.dataセクションはコピーして、残りの.bssセクションはゼロクリアすればOK。

ちなみに、この3つめのセグメントの物理Addrは `erodata` のアドレスと一致する。何故こうなるのか、わからん。。。。 
2つ目のセクションが read-only なデータが置かれるから、３つ目のセクションの物理Addr先頭になってるのかな。。。

## ブートローダ
電源ONでブートローダを起動して、シリアル経由でプログラムをダウンロードして起動するようにするらしい。
このように段階的を踏んでOSを起動する手順を ``ブートストラップ`` と呼ぶ。
フラッシュメモリは書き換え回数に制限があるので、開発時はブートローダでプログラムをRAMに展開するが、製品化の段階でフラッシュROMに書き込んでROM上から起動するようにする。(``ROM化``)

### XMODEM
シンプルなシリアル経由でのファイル転送プロトコル。

#### 送信側 
* 受信側から定期的に送られる ``NAK(0x15)`` を受けたら送信開始。
* データは固定長のブロック単位で送る。ファイル終端でデータが足りない場合は ``EOF(0x01)`` で埋める。
* 1ブロック送るたびに ``ACK(0x06)`` か ``NAK`` が返ってくるのを待つ. ``NAK`` が返ってきたら再送しなければならない。
* データの終わりは ``EOT(0x04)`` を送信して、 ``ACK``が返ってきたら終了。
* 中断する場合は ``CAN(0x18)`` を送信する。 ``CAN`` が返ってきたら中断できた。

#### 受信側
* 受信準備できたら、定期的にNAKを送信する。
* ``SOH(0x01)``を受け取ったらブロックを受信する。成功したら``ACK``を返す。
* ``EOT``を受けたら``ACK``を返して終了する。
* 中断したい場合は ``CAN`` を送る。 ``CAN`` が返ってきたら中断できた。

ブロックは先頭から・・・
* 1byte SOH
* 1byte ブロック番号 1から255の連番をループ。
* 1byte ブロック番号をビット反転したもの(チェック用)
* 128byte データ。128byteに満たない場合はEOFで埋める。
* 1byte データ部のチェックサム








